https://www.gnu.org/licenses/agpl-3.0[image:https://img.shields.io/badge/License-AGPL_v3-blue.svg[License: AGPL v3]] https://codecov.io/gh/twonirwana/DiceEvaluator[image:https://codecov.io/gh/twonirwana/DiceEvaluator/branch/main/graph/badge.svg?token=TTBM46YQFT[codecov]] https://search.maven.org/artifact/io.github.twonirwana/dice-evaluator[image:https://img.shields.io/maven-central/v/io.github.twonirwana/dice-evaluator[Maven Central]]

== The Dice Evaluator

Dice https://en.wikipedia.org/wiki/Infix_notation[infix notation] (aka calculator notation) expression evaluator, using the https://en.wikipedia.org/wiki/Shunting_yard_algorithm[shunting yard algorithm].
The dice can have numbers or text/symbols on them.
Some operators work only on numbers.
It is also possible to color dice and dice with different colors will not be combined when given to operators or functions.
This implementation was inspired by https://github.com/fathzer/javaluator[Javaluator].
The dice evaluator works on lists, summing the rolls together is optional.

=== Goals

* Always get the dice rolls in the answer, even for complex expressions
* Clear defined operator precedence and correct bracket handling
* Support for custom dice sides with text or symbols instant of numbers
* Don’t always give the sum of the dice as answer but working with lists
* Operators can handle, when possible and intuitive, lists of elements/numbers
* Custom exception for errors in the expression evaluation
* Usage of as few symbols as possible
* No infinity loops possible and configurable limits for expensive operations
* Make testing easy be providing the options to provide a custom, non-random, number generator

=== Development Decisions

* It should be possible to get the resul of each die (for e.g. pool systems) and to add the dice results together.
Therefor the default must be only append elements together and a special operator `=` must be used to sum the elements.
* Exception over unintuitive behavior -> It is better that the user knows what is not working then that something is working, but they don’t know what and why
* not every operator can handel lists -> to many operators are not intuitive:
** is max on list the count or the sum of the elements
** how to multiply and divide lists

== Usage

The evaluator processes dice expression and returns a list of rolls, each containing a list of elements.
Elements have a value (a number or a text) and can have a color.
For example `2d6` rolls two six-sided dice and returns a list with two elements, each with a value between 1 and 6. To get the sum of the roll, simple add a `=` at the end, for example in this case `2d6=`.
The same applies to numbers `3 + 5` has as result a list with the elements 3 and 5, only if written as `3 + 5=` the result is 8.
The same applies to numbers `3 + 5` has as result a list with the elements 3 and 5, only if written as `3 + 5=` the result is 8. To use text in the expression it is often necessary to escape the text with `'`. For example `1d('head' + 'tail')` will flip a coin.
Without the escape characters the d in head would be interpreted as dice operator.
List can be included into the expression by using brackets.
For example `1d[2/2/4/4/6/6]` will a die which has two sides with 2, two sides with 4 and two sides with 6. The roll will be a list with one element, which has a value of 2, 4 or 6. Lists also escape characters, so `1d[head/tail]` will also flip a coin.

Multiple expression can be separated by `,`.
For example `3d6, 4d8` will roll two six-sided dice and return a list with two rolls, the first one containing the roll elements of the `3d6` and the second one the roll of the `4d8`.

Operators have a precedent, which is defined by the order of the operators in the table below.
Operators with a higher precedence are evaluated first.
Brackets can be used to change the order of evaluation.
For example `1d4+3d6` is the appending of roll of 1d4 and 3d6, but `(1d4+3=)d6)` gets first the sum of the roll of 1d4 and 3 and then rolls this number of d6.

The number of dice is limited to 1000 and every number approve 2147483647 will be handled like text and not as number.

=== Operators

[width="100%",cols="9%,8%,7%,48%,4%,8%,8%,8%",options="header",]
|===
|Name |Notation |Example |Description |Precedent |Associativity |Left parameter |Right parameter
|Repeat |`<number>x<expression>` |`3x2d6` |Repeats the expression a number of times given in <number>. This should be used outside other expressions and will not work inside most expressions |0 |left |a single number between 1-10 | a expression
|Sum |`<left> =` |`2d6=` |Sums the list of on the left side of the symbol |1 |left |a list |-
|Multiply |`<left> * <right>` |`2 * 6` |Multiplies the right number with the left number |2 |left |a single number |a single number
|Divide |`<left> / <right>` |`4 / 2` |Divides the right number with the left number |3 |left |a single number |a single number
|Count |`<list> c` |`3d6>3c` |Counts the number of elements in a list |4 |left |a list |-
|Greater Then Filter |`<list> > <number>` |`3d6>3` |Keeps only the elements of the left list that are bigger as the right number |5 |left |one or more numbers |a single number
|Lesser Then Filter |`<list> < <number>` |`3d6<3` |Keeps only the elements of the left list that are lesser as the right number |6 |left |one or more numbers |a single number
|Greater Equal Then Filter |`<list> >= <number>` |`3d6>=3` |Keeps only the elements of the left list that are bigger or equal as the right number |7 |left |one or more numbers |a single number
|Lesser Equal Then Filter |`<list> <= <number>` |`3d6<=3` |Keeps only the elements of the left list that are lesser or equal as the right number |8 |left |one or more numbers |a single number
|Equal Filter |`<list> == <value>` |`3d6==3` |Keeps only the elements of the left list that are equal to the value |9 |left |one or more elements |a single elements
|Keep Highest |`<list> k <numberToKept>` |`3d6k2` |keeps the highest values out a list, like the roll of multiple dice |10 |left |one or more values |a single number
|Keep Lowest |`<list> l <numberToKept>` |`3d6l2` |keeps the lowest values out a list, like the roll of multiple dice |11 |left |one or more values |a single number
|Appending |`<left> + <right>` |`2d6 + 2` or `+3` |Combines the rolls of both sides to a single list. If used as unary operator, it will be ignored e.g. `+5` will process to `5` |12 (max for unary) |left for binary and right for unary |none or more value |one or more value
|Negative Appending |`<left> - <right>` |`2 - 1` or `-d6` |Combines the rolls of both sides to a single list. The right side is multiplied by -1. |13 |left for binary and right for unary |none or more value |one or more numbers
|Exploding Add Dice |`<numberOfDice>d!!<numberOfFaces>` |`3d!!6` |Throws dice and any time the max value of a die is rolled, that die is re-rolled and added to the die previous resul total. A roll of the reroll the sum of the value. |14 |left for binary and right for unary |none or a single positiv number (max 1000) |a single number
|Exploding Dice |`<numberOfDice>d!<numberOfFaces>` |`4d!6` or `d!6` |Throws dice and any time the max value of a die is rolled, that die is re-rolled and added to the dice set total. A reroll will be represented as two dice roll values |15 |left for binary and right for unary |none or a single number (max 1000) |a single positiv number
|Regular Dice |`<numberOfDice>d<numberOfFaces>` |`3d20`, `d20` or `3d[2/4/8]` |Throws a number of dice given by the left number. The number sides are given by the right number. If the right side a list, an element of the list is randomly picked. The roll is a list with the dice throw |16 |left for binary and right for unary |none or a single number (max 1000) |a single positiv number or multiple values
|===

=== Functions

[width="100%",cols="6%,22%,14%,58%",options="header",]
|===
|Name |Notation |Example |Description
|color |`color(<expression>, <'color'>)` |`color(4d6,'red')` |marks the elements of one inner expression with a text. All other operators will not combine elements of different colors.
|min |`min(<expression1>, <expression2> ...)` |`min(4d6)` |returns the smallest elements (multiple if the smallest is not unique) of one or more inner expressions. Text is compared alphabetically
|max |`max(<expression1>, <expression2> ...)` |`max(4d6)` |returns the smallest elements (multiple if the smallest is not unique) of one or more inner expressions. Text is compared alphabetically
|sort asc |`asc(<expression1>, <expression2> ...)` |`asc(4d6)` |sorts all elements ascending of one or more inner expressions. Text is compared alphabetically
|sort desc |`desc(<expression1>, <expression2> ...)` |`desc(4d6)` |sorts all elements descending of one or more inner expressions. Text is compared alphabetically
|sort desc |`desc(<expression1>, <expression2> ...)` |`desc(4d6)` |sorts all elements descending of one or more inner expressions. Text is compared alphabetically
|chancel |`chancel(<expression>, <listA>, <listB>)` |`chancel(8d10, 10, 1)` |the elements of listA and listB (can also be single elements) chancel each other and remove each other from the result.
|replace |`replace(<expression>, <find>, <replace>)` |`replace(8d10, [9/10], 'bonus')` | each element in `<expression>` that matches on of the elements in `<find>` will be replaced with the elements in `<replace>`.
|if equal |`ifE(<expression>,<compareTo>,<true>,<false>)` |`ifE(1d6,6,'six','not six')` or `ifE(1d6,6,'six')` or `ifE(1d6,6,'six',5,'five',`else`)` |compares the elements of `<expression>` and `<compareTo>` and if they are equal return the `<true>` expression or else the `<false>` expression. The `<false>` expression is optional, if it is missing and the elements are not equal, the result will be the input expression. It is possible to add more than `<compareTo>,<true>` pair in the function, the result will be the `<true>` of the first, coming from left, matching `<compareTo>`.
|if in |`ifIn(<expression>,<compareTo>,<true>,<false>)` |`ifIn(1d6,[1/6],'1or6','2-5')` or `ifIn(1d6,[1/6],'1or6')` or `ifIn(1d6,[1/6],'up',[2/5],'down',`middle`)` | returns `<true>` expression if the element of `<expression>` is in `<compareTo>` or else the `<false>` expression. `<expression>` musst provide a single value. The `<false>` expression is optional, if it is missing and the elements are not equal, the result will be the input expression. It is possible to add more than `<compareTo>,<true>` pair in the function, the result will be the `<true>` of the first, coming from left, matching `<compareTo>`.
|if greater |`ifG(<expression>,<compareTo>,<true>,<false>)` |`ifG(1d6,4,'high','low')` or `ifG(1d6,4,'high')` or `ifG(1d6,4,'high',2,'mid','low')` |compares the elements of `<expression>` and `<compareTo>` and if `<expression>` is greater than `<compareTo>` then return the `<true>` expression or else the `<false>` expression. The `<false>` expression is optional, if it is missing and the elements are not equal, the result will be the input expression. It is possible to add more than `<compareTo>,<true>` pair in the function, the result will be the `<true>` of the first, coming from left, matching `<compareTo>`. `<expression>` and `<compareTo>` need to have a single element as result.
|if lesser |`ifL(<expression>,<compareTo>,<true>,<false>)` |`ifL(1d6,3,'low','high')` or `ifL(1d6,3,'low')` or `ifL(1d6,5,'mid',3,'low','high')`|compares the elements of `<expression>` and `<compareTo>` and if `<expression>` is lesser than `<compareTo>` then return the `<true>` expression or else the `<false>` expression. The `<false>` expression is optional, if it is missing and the elements are not equal, the result will be the input expression. It is possible to add more than `<compareTo>,<true>` pair in the function, the result will be the `<true>` of the first, coming from left, matching `<compareTo>`. `<expression>` and `<compareTo>` need to have a single element as result.
|group count |`groupC(<expression1>, <expression2> ...)` |`groupC(20d6)` | counts all elements of with the same value and provides the results as list in the format of `<count>x<value>`
|concatenate  |`concat(<expression1>, <expression2> ...)` |`concat('Attack: ', 2d20, ' Damage:', 3d6+5=)` | Joining all expressions together to a single result.
|value |`val(<valueName>, <value>)` |`val($1,6d6), $1=, ($1>4)c` | Defining a value (that get evaluated once) that can be used in multiple times in the same expression. For example `val($1,6d6), $1=, ($1>4)c` would define the result of `6d6` as `$1`. Therefore `$1=` would provide the sum and `($1>4)c` the count of dice with a value greater than 4 of the same dice throw.
|reroll on |`rerollOn(<expression>, <compaire>)` |`rerollOn(10d6,[1/2])` | Reroll the expression once if any of the elements of `<expression>` are in the elements of `<compaire>`
|===

== TODO

* brackets into the roll expression
* Roll -> RollSupplier, so the same expression can be called more then once
* intersection operator
* empty element/list in expression
* concatenate operator additional to the function
* AddIf/AddIfLower/AddIfHigher?
